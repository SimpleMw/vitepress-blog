---
title: mysql 锁
date: 2024-03-07 8:48:16
---

#### 全局锁

```mysql
//加锁
FLUSH TABLES WITH READ LOCK;
//解锁
unlock tables
```

使用场景，数据库备份

```mysql
//数据库备份基础用法
mysqldump -u <用户名> -p<密码> <数据库名> > <输出文件名.sql>
```

#### 表锁

```mysql
//加读锁
lock tables table_name read;
//加写锁
lock tables table_name write;
// 释放当前会话的所有表锁
unlock tables
```

##### MySQL 读锁和写锁的区别

1. **读锁（Shared Lock）**：
   - 多个事务可以同时持有读锁，而且在读锁下可以读取数据，但不能修改数据。
   - 读锁不会阻止其他事务持有读锁或排他锁（写锁）。
   - 读锁不会阻止其他事务读取数据，但会阻止其他事务持有写锁。
2. **写锁（Exclusive Lock）**：
   - 事务持有写锁时，其他事务无法持有读锁或写锁。
   - 写锁会阻止其他事务修改数据，同时也会阻止其他事务读取或持有S

使用场景

- **读锁**适用于允许并发读取数据的情况，不会阻止其他事务读取数据。
- **写锁**适用于需要确保数据完整性的情况，会阻止其他事务读取、持有锁或写入数据。

#### 行锁

```mysql
//独占锁也即排他锁（X锁）
SELECT ... FOR UPDATE
//共享锁（S锁）
SELECT ... LOCK IN SHARE MODE
```

##### 行级锁出现的情况

1. ##### 事务中使用了明确的锁定语句**：

   在事务中使用上诉语句时，MySQL 会对选定的行进行行级锁定，以确保事务在操作期间不会被其他事务修改。

2. **更新操作**：当执行更新操作，如 `UPDATE`, `DELETE`, `INSERT` 等涉及数据修改的语句时，MySQL 会自动对受影响的行进行行级锁，以避免其他事务同时修改同一行数据。

3. **并发访问同一行数据**：当多个事务同时访问同一行数据时，MySQL 会使用行级锁来保证数据的一致性，防止并发问题的发生。

4. **事务的隔离级别设置**：在 MySQL 中，不同的事务隔离级别会影响行级锁的使用，如在 `REPEATABLE READ` 或 `SERIALIZABLE` 隔离级别下，MySQL 会更多地使用行级锁来防止脏读、不可重复读和幻影读等问题。

##### 注：

读锁会阻塞写(X)，但是不会堵塞读(S)，而写锁则会把读(S)和写(X)都堵塞

#### 元数据锁（meta data lock）

不需要显式使用，在访问一个表的时候会被自动加上，也会自动被释放

#### 记录锁（Record Lock）

1.使用`SELECT ... FOR UPDATE`会增加记录锁

2.对主键索引 与 唯一索引 对数据行进行 UPDATE 操作时

3.记录锁是锁住索引记录而不是真正的数据记录

4.没有任何索引和主键时，innodb会通过锁住聚集主键索引来实现记录锁

#### 间隙锁（GAP Lock）

```mysql
//举例
SELECT * FROM demo WHERE id > 1 FOR UPDATE
```

1.间隙锁是自动由MySQL在特定条件下加锁的，开发者无需手动实现间隙锁

2.间隙锁只在可重复读和更高级别的事务隔离级别下生效

3.在事务中对**数据范围**进行查询或更新操作时

4.在使用间隙锁时，需要注意锁的范围不能太大，以避免锁冲突和性能问题

#### 临键锁（Next-Key Lock）

1.临键锁只与非唯一索引列有关，在 唯一索引列（包括主键列）上不存在临键锁

2.当执行SELECT语句时，如果查询涉及范围查询或排序操作，并且使用了索引，MySQL会在符合条件的记录上设置临键锁，防止其他事务在这些记录之间插入新的记录，以确保查询结果的一致性



#### 锁降级

##### **唯一索引等值查询：**

1.当查询的记录是存在的，临键锁会退化成【记录锁】 
2.当查询的记录是不存在的，临键锁会退化成【间隙锁】

##### **非唯一索引等值查询：**

1.当查询的记录存在时，除了会加临键锁外，还额外加间隙锁，也就是会加两把锁。
2.当查询的记录不存在时，只会加临键锁，然后会退化为间隙锁，也就是只会加一把锁。