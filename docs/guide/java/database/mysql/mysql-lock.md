---
title: mysql 锁
date: 2024-03-07 8:48:16
---

#### 全局锁

```mysql
//加锁
FLUSH TABLES WITH READ LOCK;
//解锁
unlock tables
```

使用场景，数据库备份

```mysql
//数据库备份基础用法
mysqldump -u <用户名> -p<密码> <数据库名> > <输出文件名.sql>
```

#### 表锁

```mysql
//加读锁
lock tables table_name read;
//加写锁
lock tables table_name write;
// 释放当前会话的所有表锁
unlock tables
```

##### MySQL 读锁和写锁的区别

1. **读锁（Shared Lock）**：
   - 多个事务可以同时持有读锁，而且在读锁下可以读取数据，但不能修改数据。
   - 读锁不会阻止其他事务持有读锁或排他锁（写锁）。
   - 读锁不会阻止其他事务读取数据，但会阻止其他事务持有写锁。
2. **写锁（Exclusive Lock）**：
   - 事务持有写锁时，其他事务无法持有读锁或写锁。
   - 写锁会阻止其他事务修改数据，同时也会阻止其他事务读取或持有S

使用场景

- **读锁**适用于允许并发读取数据的情况，不会阻止其他事务读取数据。
- **写锁**适用于需要确保数据完整性的情况，会阻止其他事务读取、持有锁或写入数据。

#### 行锁

```mysql
//独占锁也即排他锁（X锁）
SELECT ... FOR UPDATE
//共享锁（S锁）
SELECT ... LOCK IN SHARE MODE
```

##### 行级锁出现的情况

1. ##### 事务中使用了明确的锁定语句**：

   在事务中使用上诉语句时，MySQL 会对选定的行进行行级锁定，以确保事务在操作期间不会被其他事务修改。

2. **更新操作**：当执行更新操作，如 `UPDATE`, `DELETE`, `INSERT` 等涉及数据修改的语句时，MySQL 会自动对受影响的行进行行级锁，以避免其他事务同时修改同一行数据。

3. **并发访问同一行数据**：当多个事务同时访问同一行数据时，MySQL 会使用行级锁来保证数据的一致性，防止并发问题的发生。

4. **事务的隔离级别设置**：在 MySQL 中，不同的事务隔离级别会影响行级锁的使用，如在 `REPEATABLE READ` 或 `SERIALIZABLE` 隔离级别下，MySQL 会更多地使用行级锁来防止脏读、不可重复读和幻影读等问题。

##### 注：

读锁会阻塞写(X)，但是不会堵塞读(S)，而写锁则会把读(S)和写(X)都堵塞

#### 元数据锁（meta data lock）

不需要显式使用，在访问一个表的时候会被自动加上，也会自动被释放

#### 记录锁（Record Lock）

1.使用`SELECT ... FOR UPDATE`会增加记录锁

2.对主键索引 与 唯一索引 对数据行进行 UPDATE 操作时

3.记录锁是锁住索引记录而不是真正的数据记录

4.没有任何索引和主键时，innodb会通过锁住聚集主键索引来实现记录锁

#### 间隙锁（GAP Lock）

```mysql
//举例
SELECT * FROM demo WHERE id > 1 FOR UPDATE
```

1.间隙锁是自动由MySQL在特定条件下加锁的，开发者无需手动实现间隙锁

2.间隙锁只在可重复读和更高级别的事务隔离级别下生效

3.在事务中对**数据范围**进行查询或更新操作时

4.在使用间隙锁时，需要注意锁的范围不能太大，以避免锁冲突和性能问题



#### 临键锁（Next-Key Lock）

1.临键锁只与非唯一索引列有关，在 唯一索引列（包括主键列）上不存在临键锁

2.当执行SELECT语句时，如果查询涉及范围查询或排序操作，并且使用了索引，MySQL会在符合条件的记录上设置临键锁，防止其他事务在这些记录之间插入新的记录，以确保查询结果的一致性





#### 共享锁和独占锁

- 共享锁（S锁）：允许持锁事务读取一行。
- 排他锁（X锁）：允许持锁事务更新或者删除一行。

事务1对某行加了共享锁(S锁)，事务2对那行数据加共享锁(S锁)被立即允许

事务1对某行加了共享锁(S锁)，事务2对那行数据加排他锁(X锁)的时候不被允许

事务1对某行加了排他锁(X锁)，事务2对那行数据加共享锁(S锁)的时候不被允许

事务1对某行加了排他锁(X锁)，事务2对那行数据加排他锁(X锁)的时候不被允许

#### 意向锁

- 意向共享锁( IS 锁)：事务想要获得一张表中某几行的共享锁
- 意向排他锁( IX 锁)： 事务想要获得一张表中某几行的排他锁

|      | `X`  | `IX` | `S`  | `IS` |
| :--- | :--- | :--- | :--- | :--- |
| `X`  | 冲突 | 冲突 | 冲突 | 冲突 |
| `IX` | 冲突 | 相容 | 冲突 | 相容 |
| `S`  | 冲突 | 冲突 | 相容 | 相容 |
| `IS` | 冲突 | 相容 | 相容 | 相容 |

注：

1.意向锁是一种表级锁

2.意向锁的主要用途 是表明有操作**正在锁定一行，或将要锁定一行**在表中



#### 锁降级

##### **唯一索引等值查询：**

1.当查询的记录是存在的，临键锁会退化成【记录锁】 

2.当查询的记录是不存在的，临键锁会退化成【间隙锁】

##### **非唯一索引等值查询：**

1.当查询的记录存在时，除了会加临键锁外，还额外加间隙锁，也就是会加两把锁。

2.当查询的记录不存在时，只会加临键锁，然后会退化为间隙锁，也就是只会加一把锁。





#### 其它锁相关场景

1.**insert** 会添加一个排他性锁(X)，以及一个插入意向锁(IX)

2.**insert on duplicate key** 会添加一个间隙锁(GAP)，一个插入意向锁(IX)，一个记录锁(RECORD)，一个临键锁（Next-Key）

横向是已持有锁，纵向是正在请求的锁

|          | GAP  | IX   | RECORD | Next-Key |
| -------- | ---- | ---- | ------ | -------- |
| GAP      | 相容 | 相容 | 相容   | 相容     |
| IX       | 冲突 | 相容 | 冲突   | 冲突     |
| RECORD   | 相容 | 相容 | 冲突   | 冲突     |
| Next-Key | 相容 | 相容 | 冲突   | 冲突     |

并发执行时

- 只有2个并行时，都会获取到间隙锁(GAP)，第一个事务执行完意向锁(IX)后，第二个事务才能加意向锁(IX)锁
- 3个并行时，都会获取到间隙锁(GAP)，第一个事务执行完意向锁(IX)后，第二个和第三个同时加上了意向锁(IX)锁，出现死锁
- 如果插入意向锁是不同间隙，不会出现死锁，若为相同间隙，在操作的时候会出现死锁