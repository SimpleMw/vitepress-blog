import{_ as a,o as e,c as t,Q as l}from"./chunks/framework.dd5a1521.js";const u=JSON.parse('{"title":"mysql 锁","description":"","frontmatter":{"title":"mysql 锁","date":"2024-03-07T08:48:16.000Z"},"headers":[],"relativePath":"guide/java/database/mysql/mysql-lock.md","filePath":"guide/java/database/mysql/mysql-lock.md"}'),s={name:"guide/java/database/mysql/mysql-lock.md"},n=l(`<h4 id="全局锁" tabindex="-1">全局锁 <a class="header-anchor" href="#全局锁" aria-label="Permalink to &quot;全局锁&quot;">​</a></h4><div class="language-mysql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">//加锁</span></span>
<span class="line"><span style="color:#e1e4e8;">FLUSH TABLES WITH READ LOCK;</span></span>
<span class="line"><span style="color:#e1e4e8;">//解锁</span></span>
<span class="line"><span style="color:#e1e4e8;">unlock tables</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">//加锁</span></span>
<span class="line"><span style="color:#24292e;">FLUSH TABLES WITH READ LOCK;</span></span>
<span class="line"><span style="color:#24292e;">//解锁</span></span>
<span class="line"><span style="color:#24292e;">unlock tables</span></span></code></pre></div><p>使用场景，数据库备份</p><div class="language-mysql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">//数据库备份基础用法</span></span>
<span class="line"><span style="color:#e1e4e8;">mysqldump -u &lt;用户名&gt; -p&lt;密码&gt; &lt;数据库名&gt; &gt; &lt;输出文件名.sql&gt;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">//数据库备份基础用法</span></span>
<span class="line"><span style="color:#24292e;">mysqldump -u &lt;用户名&gt; -p&lt;密码&gt; &lt;数据库名&gt; &gt; &lt;输出文件名.sql&gt;</span></span></code></pre></div><h4 id="表锁" tabindex="-1">表锁 <a class="header-anchor" href="#表锁" aria-label="Permalink to &quot;表锁&quot;">​</a></h4><div class="language-mysql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">//加读锁</span></span>
<span class="line"><span style="color:#e1e4e8;">lock tables table_name read;</span></span>
<span class="line"><span style="color:#e1e4e8;">//加写锁</span></span>
<span class="line"><span style="color:#e1e4e8;">lock tables table_name write;</span></span>
<span class="line"><span style="color:#e1e4e8;">// 释放当前会话的所有表锁</span></span>
<span class="line"><span style="color:#e1e4e8;">unlock tables</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">//加读锁</span></span>
<span class="line"><span style="color:#24292e;">lock tables table_name read;</span></span>
<span class="line"><span style="color:#24292e;">//加写锁</span></span>
<span class="line"><span style="color:#24292e;">lock tables table_name write;</span></span>
<span class="line"><span style="color:#24292e;">// 释放当前会话的所有表锁</span></span>
<span class="line"><span style="color:#24292e;">unlock tables</span></span></code></pre></div><h5 id="mysql-读锁和写锁的区别" tabindex="-1">MySQL 读锁和写锁的区别 <a class="header-anchor" href="#mysql-读锁和写锁的区别" aria-label="Permalink to &quot;MySQL 读锁和写锁的区别&quot;">​</a></h5><ol><li><strong>读锁（Shared Lock）</strong>： <ul><li>多个事务可以同时持有读锁，而且在读锁下可以读取数据，但不能修改数据。</li><li>读锁不会阻止其他事务持有读锁或排他锁（写锁）。</li><li>读锁不会阻止其他事务读取数据，但会阻止其他事务持有写锁。</li></ul></li><li><strong>写锁（Exclusive Lock）</strong>： <ul><li>事务持有写锁时，其他事务无法持有读锁或写锁。</li><li>写锁会阻止其他事务修改数据，同时也会阻止其他事务读取或持有S</li></ul></li></ol><p>使用场景</p><ul><li><strong>读锁</strong>适用于允许并发读取数据的情况，不会阻止其他事务读取数据。</li><li><strong>写锁</strong>适用于需要确保数据完整性的情况，会阻止其他事务读取、持有锁或写入数据。</li></ul><h4 id="行锁" tabindex="-1">行锁 <a class="header-anchor" href="#行锁" aria-label="Permalink to &quot;行锁&quot;">​</a></h4><div class="language-mysql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">//独占锁也即排他锁（X锁）</span></span>
<span class="line"><span style="color:#e1e4e8;">SELECT ... FOR UPDATE</span></span>
<span class="line"><span style="color:#e1e4e8;">//共享锁（S锁）</span></span>
<span class="line"><span style="color:#e1e4e8;">SELECT ... LOCK IN SHARE MODE</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">//独占锁也即排他锁（X锁）</span></span>
<span class="line"><span style="color:#24292e;">SELECT ... FOR UPDATE</span></span>
<span class="line"><span style="color:#24292e;">//共享锁（S锁）</span></span>
<span class="line"><span style="color:#24292e;">SELECT ... LOCK IN SHARE MODE</span></span></code></pre></div><h5 id="行级锁出现的情况" tabindex="-1">行级锁出现的情况 <a class="header-anchor" href="#行级锁出现的情况" aria-label="Permalink to &quot;行级锁出现的情况&quot;">​</a></h5><ol><li><h5 id="事务中使用了明确的锁定语句" tabindex="-1">事务中使用了明确的锁定语句**： <a class="header-anchor" href="#事务中使用了明确的锁定语句" aria-label="Permalink to &quot;事务中使用了明确的锁定语句**：&quot;">​</a></h5><p>在事务中使用上诉语句时，MySQL 会对选定的行进行行级锁定，以确保事务在操作期间不会被其他事务修改。</p></li><li><p><strong>更新操作</strong>：当执行更新操作，如 <code>UPDATE</code>, <code>DELETE</code>, <code>INSERT</code> 等涉及数据修改的语句时，MySQL 会自动对受影响的行进行行级锁，以避免其他事务同时修改同一行数据。</p></li><li><p><strong>并发访问同一行数据</strong>：当多个事务同时访问同一行数据时，MySQL 会使用行级锁来保证数据的一致性，防止并发问题的发生。</p></li><li><p><strong>事务的隔离级别设置</strong>：在 MySQL 中，不同的事务隔离级别会影响行级锁的使用，如在 <code>REPEATABLE READ</code> 或 <code>SERIALIZABLE</code> 隔离级别下，MySQL 会更多地使用行级锁来防止脏读、不可重复读和幻影读等问题。</p></li></ol><h5 id="注" tabindex="-1">注： <a class="header-anchor" href="#注" aria-label="Permalink to &quot;注：&quot;">​</a></h5><p>读锁会阻塞写(X)，但是不会堵塞读(S)，而写锁则会把读(S)和写(X)都堵塞</p><h4 id="元数据锁-meta-data-lock" tabindex="-1">元数据锁（meta data lock） <a class="header-anchor" href="#元数据锁-meta-data-lock" aria-label="Permalink to &quot;元数据锁（meta data lock）&quot;">​</a></h4><p>不需要显式使用，在访问一个表的时候会被自动加上，也会自动被释放</p><h4 id="记录锁-record-lock" tabindex="-1">记录锁（Record Lock） <a class="header-anchor" href="#记录锁-record-lock" aria-label="Permalink to &quot;记录锁（Record Lock）&quot;">​</a></h4><p>1.使用<code>SELECT ... FOR UPDATE</code>会增加记录锁</p><p>2.对主键索引 与 唯一索引 对数据行进行 UPDATE 操作时</p><p>3.记录锁是锁住索引记录而不是真正的数据记录</p><p>4.没有任何索引和主键时，innodb会通过锁住聚集主键索引来实现记录锁</p><h4 id="间隙锁-gap-lock" tabindex="-1">间隙锁（GAP Lock） <a class="header-anchor" href="#间隙锁-gap-lock" aria-label="Permalink to &quot;间隙锁（GAP Lock）&quot;">​</a></h4><div class="language-mysql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">//举例</span></span>
<span class="line"><span style="color:#e1e4e8;">SELECT * FROM demo WHERE id &gt; 1 FOR UPDATE</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">//举例</span></span>
<span class="line"><span style="color:#24292e;">SELECT * FROM demo WHERE id &gt; 1 FOR UPDATE</span></span></code></pre></div><p>1.间隙锁是自动由MySQL在特定条件下加锁的，开发者无需手动实现间隙锁</p><p>2.间隙锁只在可重复读和更高级别的事务隔离级别下生效</p><p>3.在事务中对<strong>数据范围</strong>进行查询或更新操作时</p><p>4.在使用间隙锁时，需要注意锁的范围不能太大，以避免锁冲突和性能问题</p><h4 id="临键锁-next-key-lock" tabindex="-1">临键锁（Next-Key Lock） <a class="header-anchor" href="#临键锁-next-key-lock" aria-label="Permalink to &quot;临键锁（Next-Key Lock）&quot;">​</a></h4><p>1.临键锁只与非唯一索引列有关，在 唯一索引列（包括主键列）上不存在临键锁</p><p>2.当执行SELECT语句时，如果查询涉及范围查询或排序操作，并且使用了索引，MySQL会在符合条件的记录上设置临键锁，防止其他事务在这些记录之间插入新的记录，以确保查询结果的一致性</p><h4 id="共享锁和独占锁" tabindex="-1">共享锁和独占锁 <a class="header-anchor" href="#共享锁和独占锁" aria-label="Permalink to &quot;共享锁和独占锁&quot;">​</a></h4><ul><li>共享锁（S锁）：允许持锁事务读取一行。</li><li>排他锁（X锁）：允许持锁事务更新或者删除一行。</li></ul><p>事务1对某行加了共享锁(S锁)，事务2对那行数据加共享锁(S锁)被立即允许</p><p>事务1对某行加了共享锁(S锁)，事务2对那行数据加排他锁(X锁)的时候不被允许</p><p>事务1对某行加了排他锁(X锁)，事务2对那行数据加共享锁(S锁)的时候不被允许</p><p>事务1对某行加了排他锁(X锁)，事务2对那行数据加排他锁(X锁)的时候不被允许</p><h4 id="意向锁" tabindex="-1">意向锁 <a class="header-anchor" href="#意向锁" aria-label="Permalink to &quot;意向锁&quot;">​</a></h4><ul><li>意向共享锁( IS 锁)：事务想要获得一张表中某几行的共享锁</li><li>意向排他锁( IX 锁)： 事务想要获得一张表中某几行的排他锁</li></ul><table><thead><tr><th style="text-align:left;"></th><th style="text-align:left;"><code>X</code></th><th style="text-align:left;"><code>IX</code></th><th style="text-align:left;"><code>S</code></th><th style="text-align:left;"><code>IS</code></th></tr></thead><tbody><tr><td style="text-align:left;"><code>X</code></td><td style="text-align:left;">冲突</td><td style="text-align:left;">冲突</td><td style="text-align:left;">冲突</td><td style="text-align:left;">冲突</td></tr><tr><td style="text-align:left;"><code>IX</code></td><td style="text-align:left;">冲突</td><td style="text-align:left;">相容</td><td style="text-align:left;">冲突</td><td style="text-align:left;">相容</td></tr><tr><td style="text-align:left;"><code>S</code></td><td style="text-align:left;">冲突</td><td style="text-align:left;">冲突</td><td style="text-align:left;">相容</td><td style="text-align:left;">相容</td></tr><tr><td style="text-align:left;"><code>IS</code></td><td style="text-align:left;">冲突</td><td style="text-align:left;">相容</td><td style="text-align:left;">相容</td><td style="text-align:left;">相容</td></tr></tbody></table><p>注：</p><p>1.意向锁是一种表级锁</p><p>2.意向锁的主要用途 是表明有操作<strong>正在锁定一行，或将要锁定一行</strong>在表中</p><h4 id="锁降级" tabindex="-1">锁降级 <a class="header-anchor" href="#锁降级" aria-label="Permalink to &quot;锁降级&quot;">​</a></h4><h5 id="唯一索引等值查询" tabindex="-1"><strong>唯一索引等值查询：</strong> <a class="header-anchor" href="#唯一索引等值查询" aria-label="Permalink to &quot;**唯一索引等值查询：**&quot;">​</a></h5><p>1.当查询的记录是存在的，临键锁会退化成【记录锁】</p><p>2.当查询的记录是不存在的，临键锁会退化成【间隙锁】</p><h5 id="非唯一索引等值查询" tabindex="-1"><strong>非唯一索引等值查询：</strong> <a class="header-anchor" href="#非唯一索引等值查询" aria-label="Permalink to &quot;**非唯一索引等值查询：**&quot;">​</a></h5><p>1.当查询的记录存在时，除了会加临键锁外，还额外加间隙锁，也就是会加两把锁。</p><p>2.当查询的记录不存在时，只会加临键锁，然后会退化为间隙锁，也就是只会加一把锁。</p><h4 id="其它锁相关场景" tabindex="-1">其它锁相关场景 <a class="header-anchor" href="#其它锁相关场景" aria-label="Permalink to &quot;其它锁相关场景&quot;">​</a></h4><p>1.<strong>insert</strong> 会添加一个排他性锁(X)，以及一个插入意向锁(IX)</p><p>2.<strong>insert on duplicate key</strong> 会添加一个间隙锁(GAP)，一个插入意向锁(IX)，一个记录锁(RECORD)，一个临键锁（Next-Key）</p><p>横向是已持有锁，纵向是正在请求的锁</p><table><thead><tr><th></th><th>GAP</th><th>IX</th><th>RECORD</th><th>Next-Key</th></tr></thead><tbody><tr><td>GAP</td><td>相容</td><td>相容</td><td>相容</td><td>相容</td></tr><tr><td>IX</td><td>冲突</td><td>相容</td><td>冲突</td><td>冲突</td></tr><tr><td>RECORD</td><td>相容</td><td>相容</td><td>冲突</td><td>冲突</td></tr><tr><td>Next-Key</td><td>相容</td><td>相容</td><td>冲突</td><td>冲突</td></tr></tbody></table><p>并发执行时</p><ul><li>只有2个并行时，都会获取到间隙锁(GAP)，第一个事务执行完意向锁(IX)后，第二个事务才能加意向锁(IX)锁</li><li>3个并行时，都会获取到间隙锁(GAP)，第一个事务执行完意向锁(IX)后，第二个和第三个同时加上了意向锁(IX)锁，出现死锁</li><li>如果插入意向锁是不同间隙，不会出现死锁，若为相同间隙，在操作的时候会出现死锁</li></ul>`,58),o=[n];function p(d,i,c,r,h,y){return e(),t("div",null,o)}const b=a(s,[["render",p]]);export{u as __pageData,b as default};
